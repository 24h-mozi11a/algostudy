# 컨테이너(Container)

- 컨테이너란?
  - 여러개의 값을 담을 수 있는 것(객체)으로, **서로 다른 자료형을 저장** 할 수 있음
    - ex) List, Tuple



- 컨테이너의 분류
  - 순서가 있는 데이터(Ordered) vs. 순서가 없는 데이터(Unordered)
  - 순서가 있다 != 정렬되어 있다. 
    - {1, 2, 5, 4} : 순서는 있지만 정렬되어있지는 않다.
    - 순서가 있다 : 순서를 보장받음

![image-20220129141749802](20220117_(4)컨테이너.assets/image-20220129141749802.png)

시퀀스형 : 순서가 있다

비시퀀스형 : 순서가 없다 



가변형(mutable) : 한번 정의되어도 요소를 변경하거나 삭제할  수 있음

불변형(immutable) : 한번 정의되면 요소를 변경하거나 삭제하는것이 불가능, 레퍼런스가 변경되지 않는 것에 한함. 해시가능함.



iterable : 개별 원소를 반복적으로 셀 수 있다 - 인덱스나 키를 이용해서 접근할 수 있다. 

not iterable : 개별 원소를 반복적으로 셀 수 없다 - 인덱스나 키를 이용해서 접근할 수 없다. 

-------

## 시퀀스형 컨테이너 : 리스트(List)

- 순서를 가지는(시퀀스) 0개 이상의 객체를 참조하는 자료형
  - 생성된 이후 내용 변경이 가능한 가변 자료형(mutable) 
    - 길이를 정해놓고 사용하지 않는다.
    - 무한대로 늘렸다가 줄일 수 있다. 
  - 유연성 때문에 파이썬에서 가장 흔히 사용

- 변경가능함(mutable)
- 순서가 있음(시퀀스형, ordered)
- 순회가능함(iterable)

- 항상 대괄호 형태로 출력 []

  

#### 생성과 접근

- 리스트는 대괄호([])혹은 list()를 통해 생성

```python
#1
my_list = []

#2
another_list = list()

#3 값이 있는 상태
location = ['부산', '울산', '경남']
```

- 순서가 있는 시퀀스로 인덱스를 통해 접근 가능
  - 값에 대한 접근은 list[i]

```python
				[1, 2, 3, 4, 5]
positive index : 0  1  2  3  4
negative index :-5 -4 -3 -2 -1
    
location = ['부산', '울산', '경남']
print(location[0]) #부산
```

``` python
boxes = ['A', 'B', ['apple', 'banana', 'cherry']]
print(len(boxes)) #3
print(boxes[2]) #['apple', 'banana', 'cherry']
print(boxes[2][-1]) #cherry
print(boxes[-1][1][0]) #b
```

----



## 시퀀스형 컨테이너 : 튜플(Tuple)

- 순서를 가지는 0개 이상의 객체를 참조하는 자료형
  - 생성 후, 담고 있는 객체 변경이 불가 -> 불변 자료형(immutable)

- 항상 소괄호 형태로 출력 ()



#### 생성과 접근

- 소괄호 (()) 혹은 tuple()을 통해 생성 

``` python
(1, 2, 3, 1)
tuple(1, 2, 3)
```

- 튜플은 수정 불가능한(immutable) 시퀀스로 인덱스로 접근 가능(iterable)
  - 값에 대한 접근은 my_tuple[i]

``` python
#값 접근
a = (1, 2, 3, 1)
a = [1] #2

#값 변경 - 불가능 
a = (1, 2, 3, 1)
a[2] = 2
#TypeError: 'tuple' object does not support item assignment
```



#### 생성시 주의사항

- 단일 항목의 경우
  - 하나의 항목으로 구성된 튜플은 생성 시 값 뒤에 쉼표를 붙여야 함

- 복수항목의 경우
  - 마지막 항목에 붙은 쉼표는 불필요

``` python
a = 1,
print(a) #(1,)
print(type(a)) #<class 'tuple'>

b = 1, 2, 3
print(b) #(1, 2, 3)
print(type(b)) #<class 'tuple'>
```



#### 튜플 대입 

- 우변의 값을 좌변의 변수에 한번에 할당하는 과정
- 튜플은 일반적으로 파이썬 내부에서 활용
  - 추주 함수에서 복수의 값을 반환하는 경우에도 활용

``` python
x, y = 1, 2
print(x, y) # 1 2

#실제로 튜플로 처리 
x, y = (1, 2)
print(x, y) # 1 2
```

----



## 시퀀스형 컨테이너 : 레인지(Range)

- 숫자의 시퀀스(차례)를 나타내기 위해 사용
  - 기본형 : range(n)
    - 0부터 n-1까지의 숫자의 시퀀스 

``` python
#0부터 2까지 
list(range(3)) #[0, 1, 2]
```



- 범위 지정 : range(n, m)
  - n부터 m-1까지의 숫자의 시퀀스 

``` python
#숫자의 범위 
list(range(1, 5)) #[1, 2, 3, 4]
```



- 범위 및 스텝 지정 : range(n, m, s)
  - n부터 m-1까지 s만큼 증가시키며, 숫자의 시퀀스

``` python
#step 활용
list(range(1, 5, 2)) #[1, 3]
```

- 역순 : range(m, n, -1)

``` python
#역순
print(list(range(6,1,-1))) #[6, 5, 4, 3, 2] 
print(list(range(1, 3, -1))) #[]
print(list(range(6, 1, 1))) #[]
```



#### 레인지의 용도

- range는 숫자의 시퀀스를 나타내기 위해 사용

``` python
range(4) #range(0, 4)
list(range(4)) #[0, 1, 2, 3]
print(type(range(4))) #<class 'range'>
```



----

### 패킹/언패킹 연산자(Packing/ Unpacking Operator)

- #### 패킹 

  - 대입문의 좌변 변수 위치
  - 우변의 객체 수가 좌변의 변수 수보다 많을 경우 객체를 순서대로 대입
  - 나머지 항목들은 모두 별 기호 표시된 변수에 리스트로 대입 

``` python
x, *y = 1, 2, 3, 4
print(x) #1
type(x) #int

print(y) #[2, 3, 4]
type(y) #list
```



- #### 언패킹

  - argument 이름이 *로 시작하는 경우, argument unpacking이라고 함
    - *패킹의 경우, 리스트로 대입 
    - *언패킹의 경우 튜플 형태로 대입 

``` python
def multiply(x, y, z):
    return x * y * z

numbers = [1, 2, 3]
multiply(*numbers) #6
```



### (*) 연산자의 구분

- packing/Unpacking 연산자
  - *가 대입식의 좌측에 위치하는 경우
  - *가 단항 연산자로 사용되는 경우
    - 단항 연산자 : 하나의 항을 대상으로 연산이 이루어지는 연산자 

- 산술연산자로서의 *
  - *가 이항연산자로 사용되는 경우
    - 이항 연산자 : 두개의 항을 대상으로 연산이 이루어지는 연산자

----



## 비시퀀스형 컨테이너 : 셋(set)

- 순서 없이(비시퀀스) 0개 이상의 해시가능한 객체를 참조하는 자료형
  - 해시 가능한 객체(immutable) 만 담을 수 있음
- 담고 있는 객체를 삽입, 변경, 삭제 가능 ->  가변자료형(mutable)
- 수학에서의 집합과 동일한 구조를 가짐 
  - 집합 연산이 가능
  - 중복된 값이 존재하지 않음
- 중복 없이 순서가 없는 자료구조
  - 중괄호({}) 혹은 set()을 통해 생성
    - 빈 Set을 만들기 위해서는 set()을 반드시 활용해야 함
    - {}는 dictionary

- 변경가능함(mutable)
-  순서가 없음(unordered)
- 순회 가능함(iterable)

- 순서가 없어 별도의 값에 접근할 수 없음

``` python
print({1,2,3,1,2}) #{1,2,3}
print(type({1,2,3,1,2})) #<class 'set'>

blank = {}
print(type(blank)) #<class 'dict'>
#빈 중괄호는 dictionary

blank_set = set()
print(type(blank_set)) #<class 'set'>

{1,2,3}[1] 
#TypeError: 'set' object is not subscriptable
```



#### 셋(set)  활용

- 셋을 활용하면 다른 컨테이너에서 중복된 값을 쉽게 제거할 수 있음.
  - 단, 이후 순서가 무시되므로 순서가 중요한 경우 사용할 수 없음.

- 아래의 리스트에서 고유한 지역의 개수는?

``` python
my_list = ['서울', '서울', '대전', '광주', '서울', '서울', '대전', '부산', '부산']

print(len(set(my_list))) #4

```

- 아래의 리스트에서 고유한 지역을 **등장한 순서대로 출력하시오.**
  - set으로 쓸 수 없음. 순서를 보장할 수 없음.

-----



## 비시퀀스형 컨테이너 : 딕셔너리(dictionary)

- 순서 없이 키-값(key-value)쌍으로 이뤄진 객체를 참조하는 자료형
- dictionary의 키(key)
  - 해시가능한(immutable)불변 자료형만 가능. 

- 각 키의 값(values)
  - 어떠한 형태든 관계 없음



#### 딕셔너리 생성

- key와 value가 쌍으로 이뤄진 자료구조
- 변경가능(mutable)
- 순서가 없음(비시퀀스, unordered)
- 순회가능함(iterable)
- 중괄호({}) 혹은 dict()을 통해 생성

``` python
dict_a = {}
print(type(dict_a)) #<class 'dict'>

dict_a = {'a' : 'apple', 'b' : 'banana', 'list' : [1, 2, 3]}
#{'a': 'apple', 'b': 'banana', 'list': [1, 2, 3]}


dict_b = dict()
print(type(dict_b)) #<class 'dict'>

dict_b = dict(a = 'apple', b = 'banana', list = [1, 2, 3])
print(dict_b) 
#{'a': 'apple', 'b': 'banana', 'list': [1, 2, 3]}
```



- key를 통해 value에 접근

``` python
dict_a = {'a' : 'apple', 'b' : 'banana', 'list' : [1, 2, 3]}
print(dict_a) 
#{'a': 'apple', 'b': 'banana', 'list': [1, 2, 3]}

print(dict_a['list']) 
#[1, 2, 3]
```

- key는 변경 불가능한 데이터(immutable)만 활용 가능 
  - string, integer, float, boolean, tuple, range

- value는 모든 값으로 설정 가능(List, Dictionary 등)

``` python
dict_c = {[1, 2, 3] : 'hi'}
#TypeError: unhashable type: 'list'

dict_d = {"hello" : [1, 2, 3]}
print(dict_d) #{'hello': [1, 2, 3]}
print(dict_d['hello'][0]) #1
```

----



## 형 변환(Typecasting)

- 파이썬에서 데이터 형태는 서로 변환할 수 있음

  - 암시적 형 변환(implicit)
    - 사용자가 의도하지 않고, 파이썬 내부적으로 자료형을 변환하는 경우

  - 명시적 형 변환(explicit)
    - 사용자가 특정 함수를 활용하여 의도적으로 자료형을 변환하는 경우

----



#### 암시적 형 변환(implicit Typecasting)

- 사용자가 의도하지 않고, 파이썬 내부적으로 자료형을 변환하는 경우
  - bool
  - Numeric type(int, float, complex)

``` python
True + 3 #4 <class 'int'>
3 + 5.0 #8.0 <class 'float'>
3 + 4j + 5 #(8+4j) <class 'complex'>
```

-----



#### 명시적 형 변환(Explicit Typecasting)

- int
  - str*, float => int
  - 형식에 맞는 문자열만 가능, 정수형이 아닌 경우 불가

``` python
#문자열은 암시적 타입 변환이 되지 않음
'3' + 4 
#TypeError: can only concatenate str (not "int") to str

#명시적 타입 변환이 필요함
itn('3') + 4 #7

#정수 형식이 아닌 경우 타입 변환할 수 없음
int('3.5') + 5
#ValueError: invalid literal for int() with base 10: '3.5'
```



- float
  - str*, int => float

``` python
'3.5' + 3.5
TypeError: can only concatenate str (not "float") to str
    
#정수 형식인 경우에도 float로 타입 변환
float('3')

#float형식이 아닌 경우 타입 변환할 수 없음
float('3/4') + 5.3
ValueError: could not convert string to float: '3/4'
```



- str
  - int, float, list, tuple, dict => str

-----

## 

### 컨테이너 형 변환(Container Typecasting)

- 컨테이너 간의 형 변환은 아래와 같이 가능![image-20220129195715139](20220117_(4)컨테이너.assets/image-20220129195715139.png)

## Range, Dictionary로 변경 불가능

------



## 연산자 

#### 연산자의 종류

- 산술 연산자 (arithmetic Operator)
- 비교 연산자 (Comparision Operator)
- 논리 연산자 (Logical Operator)
- 복합 연산자(In-place Operator)
- 멤버십 연산자(Membership Operator)
- 식별 연산자(Identity Operator)
- 기타(Indexing/Slicing)

-----

### 산술 연산자 

![image-20220129200203655](20220117_(4)컨테이너.assets/image-20220129200203655.png)

​                                    %(modulo)                                            나머지 

``` python
print(5 / 2) #2.5
print(4 / 2) #2.0
print(5 // 2) #2
print(int(5/2)) #2
print(5 % 2) #1
```

``` python
print(divmod(5, 2)) # (2, 1)<-tuple
quotient, remainder = divmod(5, 2)
print(quotient, remainder) # 2 1
```

----



### 비교 연산자

- 값을 비교하며, True / False 값을 리턴함

![image-20220129200712839](20220117_(4)컨테이너.assets/image-20220129200712839.png)

``` python
print(3 > 6) #False
print(3.0 == 3) #True
print(3 >= 0) #True
print('3' != 3) #True
print('Hi' == 'hi') #False
```

``` python
#특정 변수가 비어있는지 확인하기 위해서는 
#x == None이 아닌 x is None을 쓰는 것을 권장 
#OOP에서 추가 설명
x = 3
x is None #False

#PEP8:
Comparisons to None
should alwys be done with is 
never the equality operators
```

----



### 논리 연산자(logic Operator)

![image-20220129201301501](20220117_(4)컨테이너.assets/image-20220129201301501.png)

``` python
print(not True) #False
print(not -0.0) #True -> 암시적 형변환
print(not 'hi') #False -> 암시적 형변환
```

- 일반적으로 비교 연산자와 함께 사용됨 

``` python
num = 100
num >= 100 and num % 3 == 1 #True
```

- 결과가 확실한 경우 두 번째 값은 확인하지 않음
  - and 연산에서 첫번째 값이 False 인 경우 무조건 False -> 첫번째 값 반환
  - or 연산에서 첫번째 값이 True인 경우 무조건 True -> 첫번째 값 반환

``` python
a = 5 and 0
print(a) #0

b = 0 and 5
print(b) #0

c = 0 or 5
print(c) #5

d = 5 or 0
print(d) #5
```



-----



### 복합 연산자(In-Place Operator)

- 복합 연산자는 연산과 대입이 함께 이뤄짐
  - 예시) 반복문을 통해서 개수를 카운트 하는 경우 

``` python
cnt = 100
cnt += 1
print(cnt) #101
```

``` python
cnt = 0
while cnt < 3:
    print(cnt)
    cnt += 1 
    
0
1
2
```

---



### 식별 연산자(Identity Operator)

- is 연산자를 통해 동일한 객체(Object) 인지 확인 가능함.
  - OOP에서 추가 학습

``` python
#파이썬에서 -5부터 256까지 숫자의 id는 동일 
a = 3
b = 3
print(a is b) #True
print(id(a), id(b)) #2555893016944 2555893016944
```

``` python
c = 257
d = 257
print(c is d) #True
print(id(c), id(d)) #2645694065040 2645694065040
```



---



### 멤버십 연산자(Membership Operator)

- 포함 여부 확인 
  - in
  - not in 

``` python
#리스트 
1 in [3, 2] #False

#튜플
4 in (1, 2, 'hi') #False

#range
-3 in range(3) # False
 2 in range(3) # True
    
#문자열
'a' in 'apple' #True

#not in 
'b' not in 'apple' #True
```

----



### 시퀀스형 연산자(Sequence Type Operator)

- ##### 산술연산자 (+)

  - 시퀀스 간의 concatenation(연결/연쇄)

``` python
#리스트
[1, 2] + ['a']
# [1, 2, 'a']

#튜플
(1, 2) + ('a', ) #('a')면 안됨
# (1, 2, 'a')

#range
range(2) + range(2, 5)
#TypeError: unsupported operand type(s) for +: 'range' and 'range'

#문자열
'12' + 'b'
#12b
```



- ##### 반복연산자 (*)

  - 시퀀스를 반복(딕셔너리, 셋 불가)

``` python
#리스트 
[0] * 8 
# [0, 0, 0, 0, 0, 0, 0, 0]

#튜플
(1, 2) * 3
# (1, 2, 1, 2, 1, 2)

#range
range(1) * 3
#TypeError: unsupported operand type(s) for *: 'range' and 'int'

#문자열 
'hi' * 3
'hihihi'
```

----

### 

### 기타 : 인덱싱(indexing)

- 시퀀스의 특정 인덱스 값에 접근 
  - 해당 인덱스가 없는 경우 IndexError

``` python
# 리스트 
[1, 2, 3][2] #3

#튜플
(1, 2, 3)[0] #1

#range
range(3)[2] #2

#문자열
'abc'[0] #'a'

[1, 2, 3][100]
#IndexError: list index out of range
```

----



### 기타 : 슬라이싱(Slicing)

- 시퀀스를 특정 단위로 슬라이싱

``` python
#리스트 
[1, 2, 3, 5][1:4] #[2, 3, 5]

#튜플
(1, 2, 3)[:2] #(1, 2)

#range
range(10)[5:8] #range(5, 8)

#문자열
'abcd'[2:4] #cd
```



- 시퀀스를 k 간격으로 슬라이싱

``` python
#리스트 
[1, 2, 3, 5][0:4:2] #[1, 3]

#튜플
(1, 2, 3, 5)[0:4:2] #(1, 3)

#range
range(10)[1;5:3] #range(1, 5, 3)

#문자열
'abcdefg'[1:3:2] #'b'
```

``` python
s = 'abcdefghi'

s[2:5] #'cde'
s[-6:-2] #'defg'
s[2:-4] #'cde'
s[2:5:2] #'ce'
s[-6:-1:3] #'dg'
s[:3] #'abc'
s[5:] #'fghi'
s[::] #'abcdefghi'
s[0:len(s):1] #'abcdefghi'
s[::-1] #'ihgfedcba'
s[-1:-(len(s)+1):-1] #'ihgfedcba'
```

---



### 기타 : set 연산자 

- | : 합집합 

```python
A_set = {1, 2, 3, 4}
B_set = {1.0, 2, 3.0, "Hello", (1, 2, 3)}
print(A_set | B_set)
#{(1, 2, 3), 1, 2, 3, 4, 'Hello'}
```

- & : 교집합

``` python
A_set = {1, 2, 3, 4}
B_set = {1.0, 2, 3.0, "Hello", (1, 2, 3)}
print(A_set & B_set)
#{1, 2, 3}
```

- \-  : 여집합

``` python
A_set = {1, 2, 3, 4}
B_set = {1.0, 2, 3.0, "Hello", (1, 2, 3)}
print(A_set - B_set)
#{4}
```

- ^ : 대칭차

``` python
A_set = {1, 2, 3, 4}
B_set = {1.0, 2, 3.0, "Hello", (1, 2, 3)}
print(A_set ^ B_set)
#{'Hello', 4, (1, 2, 3)}
```

#### 연산자 우선 순위 

- 다음은 주요 연산자의 우선 순위이며, 작성시 유의할 것 
  - ()
  - Slicing
  - Indexing
  - **
  - 단항 연산자(+, -) : 부호
  - 산술 연산자(*,/,%)
  - 산술 연산자(+, -)
  - 비교 연산자(in, is)
  - not
  - and
  - or

 

``` python
'apple'[0] in 'ssafy' and -3**3*0 > 4%2
#False
```

----



### 프로그램 구성 단위 

- 식별자(identifier)

  - 변수, 함수, 클래스 등 프로그램이 실행되는 동안 다양한 값을 가질 수 있는 이름
  - 예약어
    - 파이썬 키워드(명령어)

  - 리터럴(literal)
    - 읽혀지는 대로 쓰여있는 값 그 자체 

``` python
#anme은 식별자, 즉 변수 
#'김싸피'는 리터럴
name = '김싸피'
```

- 표현식(Expression)
  - 새로운 데이터 값을 생성하거나 계산하는 코드 조각

- 문장(statement)
  - 특정한 작업을 수행하는 코드 전체
  - 파이썬이 실행 가능한 최소한의 코드 단위 
  - 표현식은 값을 생성하는 일부분이고, 문장은 특정 작업을 수행하는 코드 전체 
  - 모든 표현식은 문장이다. 

``` python
#하나의 값도 문장이 될 수 있다. 
'ssafy'

#표현식도 문장이 될 수 있다. 
5 * 21 - 4

#실행가능해야(executable)해야 하기 때문에 아래의 코드는 문장이 될 수 있다.
name = '

#SyntaxError: EOL while scanning string literal
```

- 함수(fuction)
  - 특정 명령을 수행하는 묶음
- 모듈(Module)
  - 함수/ 클래스의 모음 또는 하나의 프로그램을 구성하는 단위

- 패키지(Package)
  - 프로그램과 모듈 묶음 
    - 프로그램 : 실행하기 위한 것
    - 모듈 : 다른 프로그램에서 불러와 사용하기 위한 것 

- 라이브러리(Library)
  - 패키지 모음

----

