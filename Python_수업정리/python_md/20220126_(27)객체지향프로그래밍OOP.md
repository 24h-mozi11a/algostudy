### 객체(컴퓨터 과학)

컴퓨터 과학에서 객체 또는 오브젝트는 클래스에서 정의한 것을 토대로 메모리(실제 저장공간)에 할당된 것으로 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미하며, `변수, 자료 구조, 함수 또는 메소드`가 될 수 있다. 



### 객체 지향 프로그래밍(OOP)

Object-oriented Programming, OOP는 컴퓨터 프로그래밍의 패러다임 중 하나이다. 

객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 객체들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다. 



``` python
(3 + 4j).real  #복소수.실수
print((3 + 4j).real)
print((3 + 4j).imag)

#값
3.0
4.0
```

``` python
a = [3, 2, 1]
a.sort()
print(a)

#값 
[1, 2, 3]
```

```python
print('banana'.upper())

#값
BANANA
```

----



### 객체지향 프로그래밍 

 프로그램을 여러개의 독립된 객체들과 그 객체들 간의 상호작용으로 파악하는 프로그래밍 방법 

예시(시각화)

- 콘서트 
  - 가수 객체
  - 감독 객체
  - 관객 객체

파이썬은 모두 객체(object)로 이루어져 있다.

객체(object)는 특정 타입의 인스턴스(instance)이다. 

- 123, 900, 5는 모두 int의 인스턴스 
- 'hello', 'bye'는 모두 string의 인스턴스 
- [232, 89, 1],[]는 모두 list의 인스턴스 





#### 객체의 특징 

- 타입(type) : 어떤 연산자(operator)와 조작(method)이 가능한가?
- 속성(attribute) : 어떤 상태(데이터)를 가지는가?
- 조작법(method) : 어떤 행위(함수)를 할 수 있는가?



python의 객체와 클라스 (Obejct and Class in Python)

``` 
객체(Object) = 속성(Attribute) + 기능(Method)
```

``` python
list.append('a') #['a']
메서드 : 리스트 내부에 정의되어있는 append 함수
list : class List:의 인스턴스
        
        
class List:
    def append
```



---



### 절차지향 프로그래밍

##### 데이터와 함수로 인한 변화 

지금까지 배웠던 조건 반복문 함수로만 모든걸 표현하는 느낌

데이터가 외부에 존재하고, 그걸활용하려면 어떤 함수에 넣어서 리턴값을 다시 어떤 함수에 넣어서...등등-> 데이터는 function의 인자로 들어갔다가 return으로 튀어나옴.

ex) sorted() - 어떠한 리스트를  중심으로 이야기를 하는 것이 아닌, 들어온걸 return해주고 그 결과를 저장해서 사용할 수 밖에 없음. 데이터는 흘러 다니는 중

![image-20220126144859776](20220126_morning.assets/image-20220126144859776.png)

----



### 객체지향 프로그래밍 

##### 데이터와 기능(메소드)분리, 추상화된 구조(인터페이스)

객체가 존재, 그 안에 데이터, 메소드가 있음. 그리고 객체 간의 상호 작용이 가능하도록 구성

오브젝트 스스로가 데이터를 가지고 있음

ex) [].sort() - 리스트라고 하는 하나의 객체의 요소를 내부적으로 바꿀 수 있는 하나의 method가 있는 것. 코드에서 data가 중심이 되어 그것을 변화시킬 수 있는 method를 구성할 수 있다. 

![image-20220126145403703](20220126_morning.assets/image-20220126145403703.png)





``` python
#절차지향
a = [1, 2, 3]
a = sorted(a)
a = reversed(a)

#list 직접적으로 할 수 있는 것이 없다.. 흘러 다닐 뿐
#a의 움직임을 보자. a는 어느 함수에 들어가서 반환되는게 일이다..
```

``` python
#객체지향
a = [1, 2, 3]
a.sort()
a.reverse()
a.append(4)
#a가 직접 변화한다 
```

----



### 객체지향 프로그래밍이 필요한 이유

- 현실 세계를 프로그램 설계에 반영(추상화)

``` python
#절차지향

person_01 = {'name' : '로라', 'age' : 23}
person_02 = {'name' : '길동', 'age' : 232}

#이런식으로 계속...?
#여기서 인사를 하려면..
def greeting(person):
    #person : dictionary
    print('안녕하세요, ' + person['name'] + '입니다.')
    
greeting(person_02)

#값
안녕하세요, 길동입니다.
```

``` python
#객체지향

class Person:
    
    def__init__(self, name, gender):
        self.name = name
        self.gender = gender
        
    def greeting(self):
        print(f'안녕하세요, {self.name}입니다.')
        #print('안녕하세요' + self.name '입니다.')
```

``` python
jimin = Person('지민', '남')
jimin.greeting()

#값
안녕하세요, 지민입니다.
```

```python
jieun = Person('아이유', '남')
jieun.greeting()

#값
안녕하세요, 아이유입니다.
```

``` python
class Person:
    
    def greeting(self):
        print('안녕하세요, ' + self.name +'입니다.')
        
jimin = Person()
jimin.name = '지민'
jimin.phone = '01039459604'
jimin.greeting()

#값
안녕하세요, 지민입니다.
```

---



### Webex Python 07 OOP 

``` python
# class 대문자로 시작하는 이름 
class Person:
    #클래스 속성 
    population = 0
    
    #생성자 
    #특별한 데코레이터가 없는 메서드 - 인스턴스 메서드 
    #인스턴스의 속성 혹은 값을 조작하는 행위를 위한 메서드 
    #첫번째 인자로는 인스턴스 자신이 오게 될 것이다. 
    #self라는 이름은 관례적인 것이고 바꿔도 문제없지만 바꾸지 않을 것이다
    def __init__(self, name):
        #인스턴스 속성 
        self.name = name
        
kim = Person('김구현')
#kim은 Peson의 인스턴스이다.
#kim 인스턴스는 name 속성을 처음 생성할 때 할당 되어서 가지게 된다. 
print(kim.name)
#김구현
```



#### 인스턴스가 생성될 때 마다 population이 1씩 증가했으면 좋겠어

**Trial** **1 : 인스턴스 속성으로 self.population을 증가시키자** 

``` python
class Person:
    #클래스 속성 
    population = 0
    def __init__(self, name):
        #인스턴스 속성 
        self.name = name
        self.population += 1

kim = Person('김구현')
print(kim.name, kim.population) # 김구현 1

hong = Person('홍길동')
print(hong.name, hong.population) # 홍길동 1

print(Person.population) #0

#내가 원한건 사람 수 전체를 합친 2였다..
# self.population로 인해 인스턴스 속성이 되어버림
#인스턴스보다 더 상위 scope에 위치한 class.population에 영향을 미칠 수 없음
```



**Trial 2 : 인스턴스 속성으로 Person.population을 증가시키자** 

``` python
class Person:
    population = 0
    def __init__(self, name):
        self.name = name
        Person.population += 1
        
kim = Person('김구현')
print(kim.name, kim.population) #김구현 1

hong = Person('홍길동')
print(hong.name, hong.population) #홍길동 2

print(Person.population) #2

#인스턴스가 생성될 때 마다 population이 1씩 증가하는 중
#되긴 됨 근데 문제는?
#클래스 밖에서 Person.population += 1 인거랑 다를바가 없음..
#그럼 어떻게 하는데!!!
#@classmethod를 활용해보자
```



**Trial 3 : @classmethod를 활용해보자**

``` python
class Person:
    population = 0
    def __init__(self, name):
        self.name = name
        
    @classmethod
    def increase(cls):
        cls.population += 1
        
kim = Person('김구현')
Person.increase()
hong = Person('홍길동')
Person.increase()


print(Person.population) #2

#그런데,, Person.increase 말고 kim.increase 해도 증가한다.
```

----



#### @Classmethod : class Person을 상속받는 class Human을 만들어보자 

``` python
class Person:
    population = 0
    def __init__(self, name):
        self.name = name
        
    @classmethod
    def increase(cls):
        cls.population += 1

class Human(Person):
    pass

a = Human('휴먼')

print(a.name) #휴먼
print(a.population) #0 -Person.population 따라감

a.increase() #->클래스 메소드로 호출할 때는 인스턴스로 호출하지말자
print(a.population) #1 - a.population은 증가함. 그럼 Person의 population은?
print(Person.population) #0 - a는 Human 클래스의 인스턴스

#이 a로 Person 클래스의 classmethod를 호출하면, increase(cls)의 cls는 Human 클래스가 된다. 즉 Human.Population이 1 증가한 셈
#클래스 메서드는 정확히 그 클래스가 조작할 클래스의 공통 값이다. 
#Human의 인스턴스인 a가 함부로 Person의 클래스 속성을 바꿔선 안됨
#@classmethod 데코레이터가 붙었다고해서 다른곳에서 못부르는 것은 아니지만 불려간 그 클래스의 속성을 바꾸는거란걸 기억하자
```



#### @Staticmethod 

``` python
class Person:
    population = 0
    def __init__(self, name):
        self.name = name
        
    @classmethod
    def increase(cls):
        cls.population += 1
       
    #class나 instance가 가지고 있는 속성을 조작하기 보다는 모든 공통 인스턴스들이 공통적으로 어떤 행위를 할 수 있는, 단 		그것이 본인들이 가지고 있는	속성을 변경시키는 것 이외의 행위를 할 때 사용
    @staticmethod
    def decrease():
        return '인구 감소가 일어나고 있습니다.'
        
```

----



#### __population을 하면 어떤 일이 일어날까? 

``` python
class Person:
    __population = 0
    def __init__(self, name):
        self.name = name
        self.increase()
        
    @classmethod
    def increase(cls):
        cls.__population += 1
        print(cls.__population) #1

p1 = Person('p1')
Person.__population += 1 #AttributeError: type object 'Person' has no attribute '__population'       
```





#### 절차지향 프로그래밍에서 사각형의 넓이와 둘레를 구해보자

``` python
def circumference(x, y):
    return 2 * (x, y)

a = 10
b = 30
c = 300
d = 20 
square1_area = area(a, b)
square1_circumference = circumference(a, b)
square1_area = area(c, d)
square1_circumference = circumference(c, d)
```



#### 객체지향 프로그래밍에서 사각형의 넓이와 둘레를 구해보자

``` python
class Rectangle:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def area(self):
        return self.x * self.y 
    
    def circumference(self):
    	return 2 * (self.x + self.y)
    
r1 = Rectangle(10, 30)
r1.area()
r1.circumference()

r2 = Rectangle(300, 20)
r2.area()
r2.circumference()
```

----



### 객체지향 프로그래밍 

- 사각형 - class 
- 각 사각형(r1, r2) - instance
- 사각형의 정보 - attribute
  - 가로 길이, 세로 길이 

- 사각형의 행동 - method
  - 넓이를 구한다. 높이를 구한다.



#### 객체지향의 장점(from 위키피디아)

- 객체지향 프로그래밍은 **프로그램을 유연하고 변경이 용이**하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용됩니다.

- 또한 프로그래밍을 더 배우기 쉽게 하고 **소프트웨어 개발과 보수를 간편**하게 하며, 보다 **직관적인 코드 분석**을 가능하게 하는 장점을 가지고 있습니다.

-----

