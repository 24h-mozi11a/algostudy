## 함수 응용

#### 내장 함수(Built-in Funtions)

- 파이썬 인터프리터에는 항상 사용할 수 있는 많은 함수와 형이 내장되어 있음.

![image-20220131102521642](20220119_(11)함수응용.assets/image-20220131102521642.png)

------

### map 

##### map(function, iterable)

- 순회 가능한 데이터구조(iterable)의 모든 요소에 함수(function)적용하고, 그 결과를 map object로 반환 

``` python
numbers = [1, 2, 3]
result = map(str, numbers)
print(result, type(result)) #<map object at 0x0000019D62235E20> <class 'map'>
print(list(result))
```

---

### filter 

##### filter(function, iterable)

- iterable에서 function의 반환된 결과가 `True` 인 것들만 구성하여 반환합니다.
- `filter object` 를 반환합니다.
- 순회 가능한 데이터 구조(iterable)의 모든 요소에 함수(function)적용하고, 그 결과가 True인 것을 filter object로 반환 

``` python
def odd(n):
    return n % 2
numbers = [1, 2, 3]
result = filter (odd, numbers)
print(result, type(result)) # <filter object at 0x000001D757665E80> <class 'filter'>

print(list(result)) #[1, 3]
```

----

### zip

##### zip(*iterables)

- 복수의 iterable을 모아 튜플을 원소로 하는 zip object를 반환 

``` python
girls = ['jane', 'ashley', 'mary']
boys = ['justin', 'eric', 'david']
pair = list(zip(girls, boys))

print(pair) #[('jane', 'justin'), ('ashley', 'eric'), ('mary', 'david')]
```

---

### lambda 

##### lambda [parameter] : 표현식 

- 람다함수
  - 표현식을 계산한 결과값을 반환하는 함수로, 이름이 없는 함수여서 익명 함수라고도 불림 

- 특징
  - return 문을 가질 수 없음 
  - 간편 조건문 외 조건문이나 반복문을 가질 수 없음
- 장점 
  - 함수를 정의해서 사용하는 것 보다 간결하게 사용 가능 
  - def를 사용할 수 없는 곳에서도 사용 가능

``` python
def triangle_area(b, h):
    return 0.5 * b * h

lambda b, h: 0.5 * b * h
print(triangle_area(5, 6)) #15.0
```

``` python
def odd(n):
    return n % 2
numbers = [1, 2, 3]
result = filter (odd, numbers)

result = filter(lambda n : n % 2, numbers)
print(list(result)) #[1, 3]
```

----

### 재귀 함수(recursive function)

- 자기 자신을 호출하는 함수
- 무한한 호출을 목표로 하는 것이 아니며, 알고리즘 설계 및 구현에서 유용하게 활용
  - 알고리즘 중 재귀 함수로 로직을 표현하기 쉬운 경우가 있음(예 - 점화식)
  - 변수의 사용이 줄어들며, 코드의 가독성이 높아짐 

- 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성

``` python
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(4)) #24
```

### 재귀를 이용한 팩토리얼 계산

```
1! = 1
2! = 1 * 2 = 1! * 2 
3! = 1 * 2 * 3 = 2! * 3
```

재귀 함수를 이용하여 다음 셀에 팩토리얼 함수를 직접 구현해봅시다.

(점화식에 대한 고민을 통해 코드 구현을 연습합니다.)

Case(1) = `1! = 1`

Case(2) = `2! = 1 * 2` = Case(1) * 2

Case(3) = `3! = 1 * 2 * 3` = Case(2) * 3

...

Case(N) = N! = 1 * 2 * 3 * ... * N = Case(N-1) * N => N-1 단계까지의 결과 * N

이렇게 반복적인 구조 (이전 단계까지의 결과 * 현재 단계의 숫자)를 찾아내고, 이를 코드로 표현합니다.

```python
def 팩토리얼재귀(현재 단계의 숫자):
    만약, 현재 단계가 1 단계라면?
        더이상 재귀호출을 진행하지않고, 1을 반환합니다.
    그렇지 않은 경우에는 (현재 단계의 숫자 * 이전 단계의 재귀 함수의 실행 결과)를 반환합니다.
```

### 재귀 함수 주의 사항 

- 재귀 함수는 base case에 도달할 때까지 함수를 호출함
- 메모리 스택이 넘치게 되면(stack overflow) 프로그램이 동작하지 않게 됨 
- 파이썬에서는 최대 재귀 깊이(maximum recursion depth)가 1000번으로 호출 횟수가 이를 넘어가게 되면 Recursion Error발생



### 반복문을 이용한 팩토리얼 계산

반복문으로 구현해봅시다.

- 목표하는 n값 만큼 반복하여 곱을 누적합니다.

```python
def 팩토리얼반복(현재 단계의 숫자):
    시작하는 숫자는 1
    while문을 활용하여, n번만큼 결과에 곱을 누적합니다.
    최종 결과를 리턴합니다.
```

``` python
def factorial(n):
    result = 1 
    while n > 1:
        result *= n 
        n -= 1
    return result
```

